// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./UniswapV2Library.sol";
import "./interfaces/IUniswapV2Factory.sol";
import "./interfaces/IUniswapV2Router02.sol";

import {Direct} from "../node_modules/@mangrovedao/mangrove-core/src/strategies/offer_maker/abstract/Direct.sol";
import {ILiquidityProvider} from
    "../node_modules/@mangrovedao/mangrove-core/src/strategies/interfaces/ILiquidityProvider.sol";
import {TransferLib} from "../node_modules/@mangrovedao/mangrove-core/src/strategies/utils/TransferLib.sol";
import {MangroveOffer} from "../node_modules/@mangrovedao/mangrove-core/src/strategies/MangroveOffer.sol";
import {IMangrove} from "../node_modules/@mangrovedao/mangrove-core/src/IMangrove.sol";
import {IERC20, MgvLib, MgvStructs, IMaker} from "../node_modules/@mangrovedao/mangrove-core/src/MgvLib.sol";

/* GENERAL NOTES

- Volumes are represented by the 2nd token in each pair
- otherDex should be a fork of UNISWAP

- Example of a paid BOUNTY (0.00057235)

* SHOULD BE IMPLEMENT

- Check the balance of the PROVISION in Mangrove
- Implement the withdrawal of the provision from the Mangrove contract
- Check if the requested volume is available in the pair's reserves BEFORE estimation and swap
- Calculate if the losing funds on a swap is better than paying the renege bounty
    bounty=min⁡(offer.provision,(gas_used+local.offer_gasbase)×global.gasprice×109)
    renege: estimatedOut - order.wants >= -tenacity*bounty (calculate avg gasUsed)
- (optional) Function to check the density of a market
    (, MgvStructs.LocalPacked cfg) = mgv.config(pairs[i][1], pairs[i][0]);
    uint density = cfg.density();

*/

contract MangroveMaker is Direct, ILiquidityProvider {
    IMangrove mgv;
    uint256[] public spread;
    uint256[] public volume;
    uint256[] public tenacity;
    address[][] public pairs;
    address public otherDexFactory;
    address public otherDexRouter;
    uint256 public otherDexFees;

    uint256[][] public offerLists;

    constructor(
        IMangrove _mgv,
        uint256[] memory _spread,
        uint256[] memory _volume,
        uint256[] memory _tenacity,
        address[][] memory _pairs,
        address _otherDexFactory,
        address _otherDexRouter,
        uint256 _otherDexFees,
        address admin
    ) Direct(_mgv, NO_ROUTER, 100_000, admin) {
        mgv = _mgv;
        spread = _spread;
        volume = _volume;
        tenacity = _tenacity;
        pairs = _pairs;
        otherDexFactory = _otherDexFactory;
        otherDexRouter = _otherDexRouter;
        otherDexFees = _otherDexFees;

        offerLists = new uint[][](pairs.length);
        for (uint256 i = 0; i < pairs.length; i++) {
            offerLists[i] = new uint[](0);
        }
    }

    function __lastLook__(MgvLib.SingleOrder calldata order) internal override returns (bytes32 data) {
        data = super.__lastLook__(order);
    }

    ///@notice Post-hook that is invoked when the offer is taken successfully.
    ///@inheritdoc Direct
    function __posthookSuccess__(MgvLib.SingleOrder calldata order, bytes32)
        internal
        virtual
        override
        returns (bytes32)
    {
        return 0;
    }

    function __posthookFallback__(MgvLib.SingleOrder calldata order, MgvLib.OrderResult calldata result)
        internal
        virtual
        override
        returns (bytes32 data)
    {
        return 0;
    }

    // ///@inheritdoc ILiquidityProvider
    function newOffer(
        IERC20 outbound_tkn,
        IERC20 inbound_tkn,
        uint256 wants,
        uint256 gives,
        uint256 pivotId,
        uint256 gasreq /* the function is payable to allow us to provision an offer*/
    )
        public
        payable
        onlyAdmin /* only the admin of this contract is allowed to post offers using this contract*/
        returns (uint256 offerId)
    {
        (offerId,) = _newOffer(
            OfferArgs({
                outbound_tkn: outbound_tkn,
                inbound_tkn: inbound_tkn,
                wants: wants,
                gives: gives,
                gasreq: gasreq,
                gasprice: 0,
                pivotId: pivotId, // a best pivot estimate for cheap offer insertion in the offer list - this should be a parameter computed off-chain for cheaper insertion
                // fund: msg.value, // WEIs in that are used to provision the offer.
                fund: msg.value, // WEIs in that are used to provision the offer.
                noRevert: false // we want to revert on error
            })
        );
    }

    ///@inheritdoc ILiquidityProvider
    function updateOffer(
        IERC20 outbound_tkn,
        IERC20 inbound_tkn,
        uint256 wants,
        uint256 gives,
        uint256 pivotId,
        uint256 offerId,
        uint256 gasreq
    ) public payable override adminOrCaller(address(MGV)) {
        _updateOffer(
            OfferArgs({
                outbound_tkn: outbound_tkn,
                inbound_tkn: inbound_tkn,
                wants: wants,
                gives: gives,
                gasreq: gasreq,
                gasprice: 0,
                pivotId: pivotId,
                fund: msg.value,
                noRevert: false
            }),
            offerId
        );
    }

    ///@inheritdoc ILiquidityProvider
    function retractOffer(IERC20 outbound_tkn, IERC20 inbound_tkn, uint256 offerId, bool deprovision)
        public
        adminOrCaller(address(MGV))
        returns (uint256 freeWei)
    {
        return _retractOffer(outbound_tkn, inbound_tkn, offerId, deprovision);
    }
}
