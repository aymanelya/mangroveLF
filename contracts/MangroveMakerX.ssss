// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;
import "hardhat/console.sol";

import "./UniswapV2Library.sol";
import "./interfaces/IUniswapV2Factory.sol";

import {Direct} from "./mgv_src/strategies/offer_maker/abstract/Direct.sol";
import {ILiquidityProvider} from "./mgv_src/strategies/interfaces/ILiquidityProvider.sol";
import {TransferLib} from "./mgv_src/strategies/utils/TransferLib.sol";
import {MangroveOffer} from "./mgv_src/strategies/MangroveOffer.sol";
import {IMangrove} from "./mgv_src/IMangrove.sol";
import {IERC20, MgvLib, IMaker} from "./mgv_src/MgvLib.sol";

contract MangroveMaker is Direct, ILiquidityProvider {
    // Declare your variables
    IMangrove mgv;
    uint[] public spread;
    uint[] public volume;
    uint[] public tenacity;
    address[][] public pairs;
    address public otherDexFactory;
    uint public otherDexFees;

    uint[][] public offerLists;

    // Constructor to initialize default values (volume respresented by the first token of each pair)
    constructor(
        IMangrove _mgv,
        uint[] memory _spread,
        uint[] memory _volume,
        uint[] memory _tenacity,
        address[][] memory _pairs,
        address _otherDexFactory,
        uint _otherDexFees,
        address admin
    ) Direct(_mgv, NO_ROUTER, 100_000, admin) {
        mgv = _mgv;
        spread = _spread;
        volume = _volume;
        tenacity = _tenacity;
        pairs = _pairs;
        otherDexFactory = _otherDexFactory;
        otherDexFees = _otherDexFees;

        offerLists = new uint[][](pairs.length);
        for (uint i = 0; i < pairs.length; i++) {
            offerLists[i] = new uint[](0);
        }

        console.log("deployed successfully!");
    }

    // This function allows updating the values of your variables
    function updateParams(
        uint[] memory _spread,
        uint[] memory _volume,
        uint[] memory _tenacity,
        address[][] memory _pairs,
        address _otherDexFactory,
        uint _otherDexFees
    ) public {
        // You could add conditions here to restrict who can call this function
        spread = _spread;
        volume = _volume;
        tenacity = _tenacity;
        pairs = _pairs;
        otherDexFactory = _otherDexFactory;
        otherDexFees = _otherDexFees;

        offerLists = new uint[][](pairs.length);
        for (uint i = 0; i < pairs.length; i++) {
            offerLists[i] = new uint[](0);
        }
    }

    function getTrackedPairs() public view returns (address[][] memory) {
        return pairs;
    }

    function getOfferLists() public view returns (uint[][] memory) {
        return offerLists;
    }

    function createInitialOffers() public payable onlyAdmin {
        for (uint i = 0; i < pairs.length; i++) {
            // getting reserves from otherDex
            require(
                (address(pairs[i][0]) != address(0)) &&
                    (address(pairs[i][1]) != address(0)),
                "TOKEN ADDRESS IS ZERO"
            );

            address pairAddress = IUniswapV2Factory(otherDexFactory).getPair(
                pairs[i][0],
                pairs[i][1]
            );
            console.log(pairAddress);
            require(pairAddress != address(0), "PAIR_NOT_FOUND");
            (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(pairAddress)
                .getReserves();
            console.log(reserve0, reserve1);
            require(
                reserve0 > 0 && reserve1 > 0,
                "UniswapV2Library: INSUFFICIENT_LIQUIDITY"
            );

            address[] memory path = new address[](2);
            path[0] = pairs[i][0];
            path[1] = pairs[i][1];
            address[] memory pairPath = new address[](1);
            pairPath[0] = pairAddress;
            uint[] memory fees = new uint[](1);
            fees[0] = 30;

            // calculate amount of token1 expected when selling ($volume) of token0
            uint[] memory amounts = UniswapV2Library.getAmountsOut(
                volume[i],
                path,
                pairPath,
                fees
            );
            console.log(volume[i], "=>", amounts[amounts.length - 1]);
            // calculate amount of token0 necessary to buy ($volume) of token0
            path[0] = pairs[i][1];
            path[1] = pairs[i][0];
            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(
                volume[i],
                path,
                pairPath,
                fees
            );
            console.log(amounts2[0], "=>", volume[i]);

            // APPROVE NECESSARY TOKENS ON MANGROVE
            TransferLib.approveToken(
                IERC20(pairs[i][0]),
                address(mgv),
                type(uint).max
            );
            TransferLib.approveToken(
                IERC20(pairs[i][1]),
                address(mgv),
                type(uint).max
            );

            (uint offerId, ) = _newOffer(
                OfferArgs({
                    outbound_tkn: IERC20(pairs[i][0]),
                    inbound_tkn: IERC20(pairs[i][1]),
                    wants: amounts[amounts.length - 1],
                    gives: volume[i],
                    gasreq: 100000,
                    gasprice: 0,
                    pivotId: 0, // a best pivot estimate for cheap offer insertion in the offer list - this should be a parameter computed off-chain for cheaper insertion
                    fund: 100000000000000000, // WEIs in that are used to provision the offer.
                    noRevert: false // we want to revert on error
                })
            );
            console.log("OfferID:", offerId);
            (uint offerId2, ) = _newOffer(
                OfferArgs({
                    outbound_tkn: IERC20(pairs[i][1]),
                    inbound_tkn: IERC20(pairs[i][0]),
                    wants: volume[i],
                    gives: amounts2[0],
                    gasreq: 100000,
                    gasprice: 0,
                    pivotId: 0, // a best pivot estimate for cheap offer insertion in the offer list - this should be a parameter computed off-chain for cheaper insertion
                    fund: 100000000000000000, // WEIs in that are used to provision the offer.
                    noRevert: false // we want to revert on error
                })
            );
            console.log("OfferID2:", offerId2);

            offerLists[i].push(offerId);
            offerLists[i].push(offerId2);
        }
    }

    function __lastLook__(
        MgvLib.SingleOrder calldata order
    ) internal override returns (bytes32 data) {
        data = super.__lastLook__(order);
        require(order.wants == order.offer.gives(), "Algo/mustBeFullyTaken");

        // Here we should add the price check in quickswap to see if the offer is still profitable (otherwise renege)
    }

    // Simple implementation of the mangroveExecute function that is called by Mangrove to process the offer trade made by the maker
    function makerExecute(
        MgvLib.SingleOrder calldata order
    )
        external
        override(IMaker, MangroveOffer)
        onlyCaller(address(MGV))
        returns (bytes32 data)
    {
        // Invoke hook that implements a last look check during execution - it may renege on trade by reverting.
        data = __lastLook__(order);

        // check if the current contract now has enough balance to give to the maker
        require(
            IERC20(order.outbound_tkn).balanceOf(address(this)) >= order.wants,
            "MyOffer/NotEnoughFunds"
        );
        
    }

    // Example of post-hook
    // if taker order was a success, try to repost residual offer at the same price
    function makerPosthook
        SingleOrder calldata order,
        OrderResult calldata result
    ) external {
        require (msg.sender == MGV, "posthook/invalid_caller");
        if (result.mgvData == "mgv/tradeSuccess") {
            // retrieving offer data
            // the following call to updateOffer will revert if:
            // * `this` MakerContract doesn't have enough provision on Mangrove for the offer
            // * the residual/(GASREQ+offer_gasbase) is below Mangrove's minimal density
            // NB : a reverting posthook does not revert the offer execution
            Mangrove(MGV).updateOffer(
                order.outbound_tkn, // same offer List
                order.inbound_tkn,
                order.offer.wants() - order.gives, // what the offer wanted, minus what the taker order gave
                order.offer.gives() - order.wants, // what the offer was giving, minus what the taker took
                order.offerDetail.gasreq(), // keeping with the same gasreq
                order.offer.next(), // using next offer as pivot
                order.offerId // reposting the offer that was consumed
            );
        }
    }

    // ///@inheritdoc ILiquidityProvider
    function newOffer(
        IERC20 outbound_tkn,
        IERC20 inbound_tkn,
        uint wants,
        uint gives,
        uint pivotId,
        uint gasreq /* the function is payable to allow us to provision an offer*/
    )
        public
        payable
        onlyAdmin /* only the admin of this contract is allowed to post offers using this contract*/
        returns (uint offerId)
    {
        (offerId, ) = _newOffer(
            OfferArgs({
                outbound_tkn: outbound_tkn,
                inbound_tkn: inbound_tkn,
                wants: wants,
                gives: gives,
                gasreq: gasreq,
                gasprice: 0,
                pivotId: pivotId, // a best pivot estimate for cheap offer insertion in the offer list - this should be a parameter computed off-chain for cheaper insertion
                // fund: msg.value, // WEIs in that are used to provision the offer.
                fund: msg.value, // WEIs in that are used to provision the offer.
                noRevert: false // we want to revert on error
            })
        );
    }

    ///@inheritdoc ILiquidityProvider
    function updateOffer(
        IERC20 outbound_tkn,
        IERC20 inbound_tkn,
        uint wants,
        uint gives,
        uint pivotId,
        uint offerId,
        uint gasreq
    ) public payable override adminOrCaller(address(MGV)) {
        _updateOffer(
            OfferArgs({
                outbound_tkn: outbound_tkn,
                inbound_tkn: inbound_tkn,
                wants: wants,
                gives: gives,
                gasreq: gasreq,
                gasprice: 0,
                pivotId: pivotId,
                fund: msg.value,
                noRevert: false
            }),
            offerId
        );
    }

    ///@inheritdoc ILiquidityProvider
    function retractOffer(
        IERC20 outbound_tkn,
        IERC20 inbound_tkn,
        uint offerId,
        bool deprovision
    ) public adminOrCaller(address(MGV)) returns (uint freeWei) {
        return _retractOffer(outbound_tkn, inbound_tkn, offerId, deprovision);
    }
}
